<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hyperspace</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: #000; }
    #bg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
    #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
  </style>
</head>
<body>
  <!-- Three.js tunnel layer -->
  <div id="bg"></div>
  <!-- 2D canvas overlay for stars + flash -->
  <canvas id="overlay"></canvas>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    /**
     * Hyperspace — Rogue One Style
     * Three.js cylinder with procedural cloud texture + 2D star overlay
     *
     * Phases (looping):
     *   IDLE       — gentle starfield (6s)
     *   SPOOL      — stars stretch (2.5s)
     *   JUMP       — flash + whiteout (1.2s)
     *   HYPERSPACE — rotating cloud cylinder tunnel (10s)
     *   EXIT       — flash + decel (1.5s)
     *   COOLDOWN   — pause (3s)
     */

    // ═══════════════════════════════════════════════════════
    //  CONFIG
    // ═══════════════════════════════════════════════════════
    const CFG = {
      starCount: 3000,
      maxSpeed: 50,
      idleSpeed: 0.10,
      tunnelLength: 120,
      tunnelRadius: 8,
      cylinderSegments: 64,
      textureSize: 1024,
      durations: {
        idle: 6000,
        spool: 2500,
        jump: 1200,
        hyperspace: 10000,
        exit: 1500,
        cooldown: 3000,
      }
    };

    // ═══════════════════════════════════════════════════════
    //  STATE
    // ═══════════════════════════════════════════════════════
    let phase = 'idle';
    let phaseStart = 0;
    let speed = CFG.idleSpeed;
    let targetSpeed = CFG.idleSpeed;
    let globalFade = 1;
    let flashIntensity = 0;
    let tunnelOpacity = 0;
    let tunnelTargetOpacity = 0;
    let lastTime = performance.now();

    // ── Easing ──────────────────────────────────────────
    const easeInQuad = t => t * t;
    const easeOutQuad = t => 1 - (1-t)*(1-t);
    const easeInExpo = t => t === 0 ? 0 : Math.pow(2, 10*t - 10);
    const easeOutExpo = t => t === 1 ? 1 : 1 - Math.pow(2, -10*t);
    const easeInCubic = t => t*t*t;
    const easeOutCubic = t => 1 - Math.pow(1-t, 3);

    // ═══════════════════════════════════════════════════════
    //  PROCEDURAL CLOUD TEXTURE
    // ═══════════════════════════════════════════════════════
    function generateCloudTexture(size) {
      const c = document.createElement('canvas');
      c.width = size;
      c.height = size;
      const ctx = c.getContext('2d');

      // Start black
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, size, size);

      // Layer multiple noise octaves for organic cloud look
      const layers = [
        { count: 60, minR: size*0.08, maxR: size*0.25, alpha: 0.12 },  // large soft blobs
        { count: 120, minR: size*0.03, maxR: size*0.12, alpha: 0.10 }, // medium detail
        { count: 200, minR: size*0.01, maxR: size*0.05, alpha: 0.08 }, // fine wisps
        { count: 80, minR: size*0.04, maxR: size*0.15, alpha: 0.15 },  // bright highlights
      ];

      for (const layer of layers) {
        for (let i = 0; i < layer.count; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const r = layer.minR + Math.random() * (layer.maxR - layer.minR);

          // Streaky ellipses — stretch horizontally for tunnel flow feel
          const stretchX = 1.5 + Math.random() * 2.5;
          const stretchY = 0.4 + Math.random() * 0.6;

          const hue = 200 + Math.random() * 25;
          const sat = 50 + Math.random() * 40;
          const light = 45 + Math.random() * 35;

          const g = ctx.createRadialGradient(x, y, 0, x, y, r);
          g.addColorStop(0, `hsla(${hue}, ${sat}%, ${light}%, ${layer.alpha})`);
          g.addColorStop(0.4, `hsla(${hue+5}, ${sat-10}%, ${light-5}%, ${layer.alpha * 0.6})`);
          g.addColorStop(1, `hsla(${hue}, ${sat-20}%, ${light-15}%, 0)`);

          ctx.save();
          ctx.translate(x, y);
          ctx.scale(stretchX, stretchY);
          ctx.translate(-x, -y);
          ctx.fillStyle = g;
          ctx.fillRect(x - r * stretchX, y - r, r * stretchX * 2, r * 2);
          ctx.restore();
        }
      }

      // Add some dark void patches for contrast (like Rogue One frames 17-18)
      for (let i = 0; i < 25; i++) {
        const x = Math.random() * size;
        const y = Math.random() * size;
        const r = size * (0.03 + Math.random() * 0.08);
        const g = ctx.createRadialGradient(x, y, 0, x, y, r);
        g.addColorStop(0, 'rgba(0, 2, 10, 0.25)');
        g.addColorStop(0.6, 'rgba(0, 5, 15, 0.12)');
        g.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
      }

      // Bright hot spots (the secondary bright spots from reference)
      for (let i = 0; i < 15; i++) {
        const x = Math.random() * size;
        const y = Math.random() * size;
        const r = size * (0.01 + Math.random() * 0.04);
        const g = ctx.createRadialGradient(x, y, 0, x, y, r);
        g.addColorStop(0, 'rgba(200, 230, 255, 0.3)');
        g.addColorStop(0.3, 'rgba(140, 190, 255, 0.15)');
        g.addColorStop(1, 'rgba(80, 150, 255, 0)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
      }

      // Make it tile seamlessly — blend edges
      const blendW = size * 0.15;
      // Horizontal wrap
      const edgeData = ctx.getImageData(0, 0, blendW, size);
      const tempC = document.createElement('canvas');
      tempC.width = blendW; tempC.height = size;
      tempC.getContext('2d').putImageData(edgeData, 0, 0);
      ctx.save();
      ctx.globalAlpha = 0.5;
      ctx.drawImage(tempC, size - blendW, 0);
      ctx.restore();

      return c;
    }

    // ═══════════════════════════════════════════════════════
    //  THREE.JS TUNNEL SETUP
    // ═══════════════════════════════════════════════════════
    const container = document.getElementById('bg');
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 1);
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.set(0, 0, 0);
    camera.lookAt(0, 0, -1);

    // Generate cloud texture
    const cloudCanvas = generateCloudTexture(CFG.textureSize);
    const cloudTexture = new THREE.CanvasTexture(cloudCanvas);
    cloudTexture.wrapS = THREE.RepeatWrapping;
    cloudTexture.wrapT = THREE.RepeatWrapping;
    cloudTexture.repeat.set(3, 1); // tile along length

    // Cylinder — camera sits inside
    const cylGeom = new THREE.CylinderGeometry(
      CFG.tunnelRadius, CFG.tunnelRadius,
      CFG.tunnelLength,
      CFG.cylinderSegments, 1, true
    );
    const cylMat = new THREE.MeshBasicMaterial({
      map: cloudTexture,
      side: THREE.BackSide,   // render inside faces
      transparent: true,
      opacity: 0,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
    });
    const cylinder = new THREE.Mesh(cylGeom, cylMat);
    cylinder.rotation.x = Math.PI / 2; // align along Z axis
    cylinder.position.z = -CFG.tunnelLength / 2;
    scene.add(cylinder);

    // Second cylinder layer — slightly different texture offset for depth
    const cloudCanvas2 = generateCloudTexture(CFG.textureSize);
    const cloudTexture2 = new THREE.CanvasTexture(cloudCanvas2);
    cloudTexture2.wrapS = THREE.RepeatWrapping;
    cloudTexture2.wrapT = THREE.RepeatWrapping;
    cloudTexture2.repeat.set(2, 1);

    const cylMat2 = new THREE.MeshBasicMaterial({
      map: cloudTexture2,
      side: THREE.BackSide,
      transparent: true,
      opacity: 0,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
    });
    const cylinder2 = new THREE.Mesh(
      new THREE.CylinderGeometry(
        CFG.tunnelRadius * 1.15, CFG.tunnelRadius * 1.15,
        CFG.tunnelLength, CFG.cylinderSegments, 1, true
      ),
      cylMat2
    );
    cylinder2.rotation.x = Math.PI / 2;
    cylinder2.position.z = -CFG.tunnelLength / 2;
    scene.add(cylinder2);

    // Third layer — tight inner glow cylinder
    const cloudCanvas3 = generateCloudTexture(CFG.textureSize);
    const cloudTexture3 = new THREE.CanvasTexture(cloudCanvas3);
    cloudTexture3.wrapS = THREE.RepeatWrapping;
    cloudTexture3.wrapT = THREE.RepeatWrapping;
    cloudTexture3.repeat.set(4, 1);

    const cylMat3 = new THREE.MeshBasicMaterial({
      map: cloudTexture3,
      side: THREE.BackSide,
      transparent: true,
      opacity: 0,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
    });
    const cylinder3 = new THREE.Mesh(
      new THREE.CylinderGeometry(
        CFG.tunnelRadius * 0.7, CFG.tunnelRadius * 0.7,
        CFG.tunnelLength, CFG.cylinderSegments, 1, true
      ),
      cylMat3
    );
    cylinder3.rotation.x = Math.PI / 2;
    cylinder3.position.z = -CFG.tunnelLength / 2;
    scene.add(cylinder3);

    // Central glow light (bright convergence orb)
    const orbGeom = new THREE.SphereGeometry(0.5, 16, 16);
    const orbMat = new THREE.MeshBasicMaterial({
      color: 0xccddff,
      transparent: true,
      opacity: 0,
      blending: THREE.AdditiveBlending,
    });
    const orb = new THREE.Mesh(orbGeom, orbMat);
    orb.position.z = -25;
    scene.add(orb);

    // (halo removed — orb handles convergence glow)

    // ═══════════════════════════════════════════════════════
    //  2D CANVAS — Stars + Flash + Fade
    // ═══════════════════════════════════════════════════════
    const canvas = document.getElementById('overlay');
    const ctx = canvas.getContext('2d');
    let W, H, cx, cy;

    class Star {
      constructor() { this.reset(true); }

      reset(scatter = false) {
        if (scatter) {
          this.x = (Math.random() - 0.5) * 2.8;
          this.y = (Math.random() - 0.5) * 2.8;
          this.z = Math.random() * 1.8 + 0.01;
        } else {
          const angle = Math.random() * Math.PI * 2;
          const maxDist = speed > 2 ? 0.04 : 0.9;
          const dist = Math.random() * maxDist + 0.001;
          this.x = Math.cos(angle) * dist;
          this.y = Math.sin(angle) * dist;
          this.z = 1.5 + Math.random() * 0.5;
        }
        this.baseSize = Math.random() * 1.2 + 0.2;
        this.brightness = Math.random() * 0.5 + 0.5;
        this.twinkle = Math.random() * Math.PI * 2;
        this.twinkleSpd = 0.5 + Math.random() * 2;

        const roll = Math.random();
        if (roll < 0.6) {
          this.r = 160 + Math.random() * 70;
          this.g = 190 + Math.random() * 50;
          this.b = 255;
        } else if (roll < 0.88) {
          this.r = 230 + Math.random() * 25;
          this.g = 238 + Math.random() * 17;
          this.b = 250 + Math.random() * 5;
        } else {
          this.r = 255;
          this.g = 230 + Math.random() * 25;
          this.b = 200 + Math.random() * 30;
        }
      }

      update(dt, spd) {
        this.z -= spd * dt;
        this.twinkle += this.twinkleSpd * dt;
        if (this.z <= 0.001) this.reset(false);
      }

      draw(ctx, spd) {
        const scale = 1 / this.z;
        const sx = cx + this.x * scale * cx;
        const sy = cy + this.y * scale * cy;

        if (sx < -200 || sx > W + 200 || sy < -200 || sy > H + 200) {
          this.reset(false); return;
        }

        // Cap star size to prevent giant bubbles
        const rawSize = this.baseSize * scale * 0.7;
        const size = Math.min(rawSize, 3.5);
        const tw = 0.7 + Math.sin(this.twinkle) * 0.3;
        const alpha = Math.min(0.95, this.brightness * Math.min(scale, 5) * 0.25) * tw;
        const r = Math.round(this.r), g = Math.round(this.g), b = Math.round(this.b);

        if (spd > 0.8) {
          const streakFactor = Math.min(spd / 3, 35);
          const prevZ = this.z + spd * 0.016;
          const prevScale = 1 / prevZ;
          const prevSx = cx + this.x * prevScale * cx;
          const prevSy = cy + this.y * prevScale * cy;
          const dx = sx - prevSx, dy = sy - prevSy;
          const len = Math.sqrt(dx*dx + dy*dy);

          if (len > 0.3) {
            const sLen = len * streakFactor;
            const nx = dx/len, ny = dy/len;
            const grad = ctx.createLinearGradient(sx-nx*sLen, sy-ny*sLen, sx, sy);
            const ca = Math.min(0.85, alpha * 1.3);
            grad.addColorStop(0, `rgba(${r},${g},${b},0)`);
            grad.addColorStop(0.35, `rgba(${r},${g},${b},${ca*0.12})`);
            grad.addColorStop(0.7, `rgba(${r},${g},${b},${ca*0.45})`);
            grad.addColorStop(1, `rgba(${r},${g},${b},${ca})`);
            ctx.beginPath();
            ctx.strokeStyle = grad;
            ctx.lineWidth = Math.min(size * 0.35 + spd * 0.02, 2.5);
            ctx.moveTo(sx-nx*sLen, sy-ny*sLen);
            ctx.lineTo(sx, sy);
            ctx.stroke();
            if (spd > 8 && size > 0.5) {
              ctx.beginPath();
              ctx.fillStyle = `rgba(255,255,255,${ca*0.6})`;
              ctx.arc(sx, sy, Math.min(size*0.15, 1.2), 0, Math.PI*2);
              ctx.fill();
            }
          }
        } else {
          // Subtle glow for brighter stars only
          if (size > 1.0 && alpha > 0.3) {
            const glowSz = Math.min(size * 2, 6);
            const glow = ctx.createRadialGradient(sx, sy, 0, sx, sy, glowSz);
            glow.addColorStop(0, `rgba(${r},${g},${b},${alpha*0.12})`);
            glow.addColorStop(1, `rgba(${r},${g},${b},0)`);
            ctx.fillStyle = glow;
            ctx.beginPath();
            ctx.arc(sx, sy, glowSz, 0, Math.PI*2);
            ctx.fill();
          }
          ctx.beginPath();
          ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
          ctx.arc(sx, sy, Math.max(Math.min(size*0.4, 1.8), 0.3), 0, Math.PI*2);
          ctx.fill();
        }
      }
    }

    let stars = [];
    function initStars() {
      stars = [];
      for (let i = 0; i < CFG.starCount; i++) stars.push(new Star());
    }

    // ═══════════════════════════════════════════════════════
    //  PHASE MANAGEMENT
    // ═══════════════════════════════════════════════════════
    function setPhase(p) { phase = p; phaseStart = performance.now(); }
    function phaseProgress() {
      return Math.min((performance.now() - phaseStart) / (CFG.durations[phase] || 5000), 1);
    }

    // ═══════════════════════════════════════════════════════
    //  RESIZE
    // ═══════════════════════════════════════════════════════
    function resize() {
      const dpr = window.devicePixelRatio || 1;
      W = canvas.width = window.innerWidth * dpr;
      H = canvas.height = window.innerHeight * dpr;
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      cx = W / 2; cy = H / 2;

      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // ═══════════════════════════════════════════════════════
    //  RENDER LOOP
    // ═══════════════════════════════════════════════════════
    function render(now) {
      requestAnimationFrame(render);
      const dt = Math.min((now - lastTime) / 1000, 0.1);
      lastTime = now;
      const p = phaseProgress();

      // ── Phase logic ──────────────────────────────
      switch (phase) {
        case 'idle':
          targetSpeed = CFG.idleSpeed;
          tunnelTargetOpacity = 0;
          flashIntensity = Math.max(0, flashIntensity - dt * 2);
          globalFade = Math.max(0, globalFade - dt * 0.8);
          if (p >= 1) setPhase('spool');
          break;

        case 'spool':
          targetSpeed = CFG.idleSpeed + easeInCubic(p) * 5;
          tunnelTargetOpacity = 0;
          flashIntensity = 0;
          if (p >= 1) setPhase('jump');
          break;

        case 'jump':
          targetSpeed = 5 + easeInExpo(p) * (CFG.maxSpeed - 5);
          tunnelTargetOpacity = easeInQuad(Math.max(0, p - 0.4) / 0.6);

          if (p < 0.35) flashIntensity = easeInQuad(p / 0.35) * 0.5;
          else if (p < 0.7) flashIntensity = 0.5 + easeInQuad((p-0.35)/0.35) * 0.45;
          else flashIntensity = 0.95 * (1 - easeOutQuad((p-0.7)/0.3));

          if (p >= 1) setPhase('hyperspace');
          break;

        case 'hyperspace':
          targetSpeed = CFG.maxSpeed + Math.sin(p * Math.PI * 5) * 2;
          tunnelTargetOpacity = 0.85 + Math.sin(p * Math.PI * 3) * 0.1;
          flashIntensity = Math.max(0, flashIntensity - dt * 3);
          if (p >= 1) setPhase('exit');
          break;

        case 'exit':
          targetSpeed = CFG.maxSpeed * (1 - easeOutExpo(p));
          if (targetSpeed < CFG.idleSpeed) targetSpeed = CFG.idleSpeed;
          tunnelTargetOpacity = 0.85 * (1 - easeOutCubic(p));

          if (p < 0.15) flashIntensity = (0.15 - p) * 6;
          else flashIntensity = Math.max(0, flashIntensity - dt * 3);

          if (p >= 1) setPhase('cooldown');
          break;

        case 'cooldown':
          targetSpeed = CFG.idleSpeed;
          tunnelTargetOpacity = 0;
          flashIntensity = 0;
          if (p >= 1) setPhase('idle');
          break;
      }

      // Smooth interpolation
      speed += (targetSpeed - speed) * Math.min(1, dt * 8);
      tunnelOpacity += (tunnelTargetOpacity - tunnelOpacity) * Math.min(1, dt * 5);

      // ── THREE.JS TUNNEL ────────────────────────────
      // Scroll textures forward (simulates flying through tunnel)
      const scrollSpeed = speed * dt * 0.08;
      cloudTexture.offset.y += scrollSpeed;
      cloudTexture2.offset.y += scrollSpeed * 0.7;
      cloudTexture3.offset.y += scrollSpeed * 1.2;

      // No rotation — tunnel stays centered and straight

      // Set opacity
      cylMat.opacity = tunnelOpacity * 0.55;
      cylMat2.opacity = tunnelOpacity * 0.35;
      cylMat3.opacity = tunnelOpacity * 0.45;

      // Central orb
      const orbPulse = 0.8 + Math.sin(now * 0.003) * 0.15 + Math.sin(now * 0.007) * 0.05;
      orbMat.opacity = tunnelOpacity * 0.9 * orbPulse;
      orb.scale.setScalar(0.3 + tunnelOpacity * 1.2 * orbPulse);

      // Background color shift — dark to deep blue during tunnel
      const bgBlue = tunnelOpacity * 0.12;
      renderer.setClearColor(
        new THREE.Color(bgBlue * 0.1, bgBlue * 0.25, bgBlue),
        1
      );

      renderer.render(scene, camera);

      // ── 2D OVERLAY ─────────────────────────────────
      // Always clear overlay to transparent so Three.js tunnel shows through
      ctx.clearRect(0, 0, W, H);

      // Stars
      for (const star of stars) {
        star.update(dt, speed);
        star.draw(ctx, speed);
      }

      // Flash overlay
      if (flashIntensity > 0.01) {
        ctx.fillStyle = `rgba(255,252,240,${flashIntensity})`;
        ctx.fillRect(0, 0, W, H);
      }

      // Global fade
      if (globalFade > 0.001) {
        ctx.fillStyle = `rgba(0,0,0,${globalFade})`;
        ctx.fillRect(0, 0, W, H);
      }
    }

    // ═══════════════════════════════════════════════════════
    //  BOOT
    // ═══════════════════════════════════════════════════════
    window.addEventListener('resize', resize);
    document.addEventListener('keydown', (e) => {
      if (['ArrowLeft','ArrowRight'].includes(e.key)) {
        window.parent.postMessage({ type: 'keydown', key: e.key }, '*');
      }
    });

    resize();
    initStars();
    globalFade = 1;
    setPhase('idle');
    requestAnimationFrame(render);

    window.parent.postMessage({ type: 'pageReady', page: 'hyperspace' }, '*');
  </script>
</body>
</html>
